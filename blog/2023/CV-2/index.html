<!DOCTYPE html> <html> <head> <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"> <meta charset="utf-8"> <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"> <meta http-equiv="X-UA-Compatible" content="IE=edge"> <title> Computer Vision Basics (Part 1)- Image Formation | Suraj Bhor </title> <meta name="author" content="Suraj Bhor"> <meta name="description" content="A simple, whitespace theme for academics. Based on [*folio](https://github.com/bogoli/-folio) design. "> <meta name="keywords" content="jekyll, jekyll-theme, academic-website, portfolio-website"> <link rel="stylesheet" href="/assets/css/bootstrap.min.css?a4b3f509e79c54a512b890d73235ef04"> <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/mdbootstrap@4.20.0/css/mdb.min.css" integrity="sha256-jpjYvU3G3N6nrrBwXJoVEYI/0zw8htfFnhT9ljN3JJw=" crossorigin="anonymous"> <link defer rel="stylesheet" href="/assets/css/academicons.min.css?f0b7046b84e425c55f3463ac249818f5"> <link defer rel="stylesheet" type="text/css" href="https://fonts.googleapis.com/css?family=Roboto:300,400,500,700|Roboto+Slab:100,300,400,500,700|Material+Icons&amp;display=swap"> <link defer rel="stylesheet" href="/assets/css/jekyll-pygments-themes-github.css?591dab5a4e56573bf4ef7fd332894c99" media="" id="highlight_theme_light"> <link rel="shortcut icon" href="data:image/svg+xml,&lt;svg%20xmlns=%22http://www.w3.org/2000/svg%22%20viewBox=%220%200%20100%20100%22&gt;&lt;text%20y=%22.9em%22%20font-size=%2290%22&gt;%E2%9A%9B%EF%B8%8F&lt;/text&gt;&lt;/svg&gt;"> <link rel="stylesheet" href="/assets/css/main.css?d41d8cd98f00b204e9800998ecf8427e"> <link rel="canonical" href="https://suraj-bhor.github.io/blog/2023/CV-2/"> <link defer rel="stylesheet" href="/assets/css/jekyll-pygments-themes-native.css?5847e5ed4a4568527aa6cfab446049ca" media="none" id="highlight_theme_dark"> <script src="/assets/js/theme.js?0afe9f0ae161375728f7bcc5eb5b4ab4"></script> <script defer src="https://cdn.jsdelivr.net/npm/medium-zoom@1.1.0/dist/medium-zoom.min.js" integrity="sha256-ZgMyDAIYDYGxbcpJcfUnYwNevG/xi9OHKaR/8GK+jWc=" crossorigin="anonymous"></script> <script defer src="/assets/js/zoom.js?85ddb88934d28b74e78031fd54cf8308"></script> <script src="https://cdn.jsdelivr.net/npm/jquery@3.6.0/dist/jquery.min.js" integrity="sha256-/xUj+3OJU5yExlq6GSYGSHk7tPXikynS7ogEvDej/m4=" crossorigin="anonymous"></script> <script type="text/javascript">window.MathJax={tex:{tags:"ams"}};</script> <script defer type="text/javascript" id="MathJax-script" src="https://cdn.jsdelivr.net/npm/mathjax@3.2.0/es5/tex-mml-chtml.js"></script> <script defer src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script> <script src="/assets/js/distillpub/template.v2.js"></script> <script src="/assets/js/distillpub/transforms.v2.js"></script> <script src="/assets/js/distillpub/overrides.js"></script> </head> <body> <d-front-matter> <script async type="text/json">
      {
            "title": "Computer Vision Basics (Part 1)- Image Formation",
            "description": "",
            "published": "May 25, 2023",
            "authors": [
              
              {
                "author": "Suraj Bhor",
                "authorURL": "https://suraj-bhor.github.io/",
                "affiliations": [
                  {
                    "name": "University of Tübingen, Germany",
                    "url": ""
                  }
                ]
              }
              
            ],
            "katex": {
              "delimiters": [
                {
                  "left": "$",
                  "right": "$",
                  "display": false
                },
                {
                  "left": "$$",
                  "right": "$$",
                  "display": true
                }
              ]
            }
          }
    </script> </d-front-matter> <header> <nav id="navbar" class="navbar navbar-light navbar-expand-sm fixed-top" role="navigation"> <div class="container"> <a class="navbar-brand title font-weight-lighter" href="/"> Suraj Bhor </a> <button class="navbar-toggler collapsed ml-auto" type="button" data-toggle="collapse" data-target="#navbarNav" aria-controls="navbarNav" aria-expanded="false" aria-label="Toggle navigation"> <span class="sr-only">Toggle navigation</span> <span class="icon-bar top-bar"></span> <span class="icon-bar middle-bar"></span> <span class="icon-bar bottom-bar"></span> </button> <div class="collapse navbar-collapse text-right" id="navbarNav"> <ul class="navbar-nav ml-auto flex-nowrap"> <li class="nav-item "> <a class="nav-link" href="/">Suraj Bhor </a> </li> <li class="nav-item "> <a class="nav-link" href="/blog/">Blog </a> </li> <li class="nav-item "> <a class="nav-link" href="/repositories/">Projects </a> </li> <li class="nav-item "> <a class="nav-link" href="/cv/">CV </a> </li> <li class="toggle-container"> <button id="light-toggle" title="Change theme"> <i class="fa-solid fa-moon"></i> <i class="fa-solid fa-sun"></i> </button> </li> </ul> </div> </div> </nav> <progress id="progress" value="0"> <div class="progress-container"> <span class="progress-bar"></span> </div> </progress> </header> <div class="post distill"> <d-title> <h1>Computer Vision Basics (Part 1)- Image Formation</h1> <p></p> </d-title> <d-byline></d-byline> <d-article> <d-contents> <nav class="l-text figcaption"> <h3>Contents</h3> <div> <a href="#primitives-and-transformations">Primitives and Transformations</a> </div> <div> <a href="#geometric-image-formation">Geometric Image Formation</a> </div> <div> <a href="#photometric-image-formation">Photometric Image Formation</a> </div> <div> <a href="#image-sensing-pipeline">Image Sensing Pipeline</a> </div> <div> <a href="#conclusion">Conclusion</a> </div> </nav> </d-contents> <h2 id="11-primitives-and-transformations">1.1 Primitives and Transformations</h2> <p>Geometric primitives are the basic building blocks used to describe 3D shapes. In this section, points, lines and planes will be introduced. We will also discuss some basic transformations.</p> <p>2D points can be written in inhomogeneous coordinated (as opposed to homogenous ones) by</p> \[x = \begin{pmatrix} x \\ y \end{pmatrix} \in \mathbb{R}^2\] <p>or in homogenous coordinates as</p> \[x = \begin{pmatrix} \widetilde{x} \\ \widetilde{y} \\ \widetilde{w} \end{pmatrix} \in \mathbb{P}^2\] <p>where \(\mathbb{P}^2 = \mathbb{R}^3 \backslash \{(0,0,0)\}\) is called <span style="color: red;">projective space.</span> Introducing a third coordinate here, we are in 3D space (except at 0,0,0). A tilde sign is a convention for a homogeneous coordinates. Homogeneous vectors are considered as equivalent when they differ onl up to scale. Thats why projective space is effectively only 2D.</p> <p>An <strong>inhomogeneous</strong> vector x is converted to a <strong>homogeneous</strong> vector x as follows:</p> \[\widetilde{x} = \begin{pmatrix} \widetilde{x} \\ \widetilde{y} \\ \widetilde{w} \end{pmatrix} = \begin{pmatrix} x \\ y \\ 1 \end{pmatrix} = \begin{pmatrix} x \\ 1 \end{pmatrix} = \bar{x}\] <p>with augmented vector \(\bar{x}\). We say augmented vector \(\bar{x}\) for all homogeneous vectors which last coordinate is equal to 1.</p> <p>To convert in the opposite direction we divide by the last element \(\widetilde{w}:\)</p> \[x = \begin{pmatrix} x \\ 1 \end{pmatrix} = \begin{pmatrix} x \\ y \\ 1 \end{pmatrix} = \frac{1}{\widetilde{w}} \widetilde{x} = \frac{1}{\widetilde{w}} \begin{pmatrix} \widetilde{x} \\ \widetilde{y} \\ \widetilde{w} \end{pmatrix} = \begin{pmatrix} \widetilde{x}\mathbin{/}{\widetilde{w}} \\ \widetilde{y}\mathbin{/}{\widetilde{w}} \\ 1 \end{pmatrix}\] <p>Like this, the last element of the homogeneous vector turens into a 1 and we can read off the x and y for the inhomogeneous coordinates. Homogeneous points whose last element is \(\widetilde{w} = 0\) are called <strong>ideal points</strong> or <strong>points at infinity</strong>. These poinits can’t be represented with inhomogeneous coordinates as we can’t divide by \(\widetilde{w}\).<d-footnote>The transformation from homogenous to inhomogeneous vectors resembles a lot the perspective translation that is introduced later.</d-footnote></p> <div class="row mt-3"> <div class="col-sm mt-3 mt-md-0"> <figure> <picture> <img src="/assets/img/CV1/2dpoints_cv1.png" class="img-fluid rounded z-depth-1" width="100%" height="auto" loading="lazy" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"> </picture> </figure> </div> </div> <div class="caption"> Figure 1: Visual relation between 2D points both in Homogeneous and Inhomogeneous coordinate system along with the augmented vector $\color{green}\bar{x}$. <i>Image from lecture slides of Computer Vision course taught by Prof. Dr. Andreas Geiger at University of Tuebingen.<d-cite key="Geiger:CV"></d-cite></i> </div> <p>Now after the 2D points, we turn on to 2D lines. So, similar to the 2D points we can also represent 2D lines via the homogeneous coordinates as follows:</p> \[\{\bar{x} \hspace{0.2cm}\vert\hspace{0.2cm} \widetilde{\mathbf{l}}^\intercal \bar{x} = 0\} \Leftrightarrow \{x,y\hspace{0.2cm}\vert\hspace{0.2cm} ax+by+x=0\}\] <p>where \(\widetilde{\mathbf{l}}=(a,b,c)^\intercal\).<br> Here we can see that the inner product of the vector \(\widetilde{\mathbf{l}}\) with the augmented vector \(\bar{x}\) gives us the line equation. Note that we can use any vector (not only the augmented one). We can normalize the line equation vector so that \(\widetilde{\mathbf{l}} = (x_x,n_y,d)^\intercal = (\boldsymbol{n},d)^\intercal\) with \(\lVert n \rVert _2 =1\). In this case, \(\boldsymbol{n}\) is the normal vector perpendicular to the line and \(d\) is its distance to the origin. An exception is the line at infinity \(\widetilde{\mathbf{l}}_\infty = (0,0,1)^\intercal\) which passes through all the ideal points i.e we can’t normalize these lines since we have to divide by zero.</p> <div class="row mt-3"> <div class="col-sm mt-3 mt-md-0"> <figure> <picture> <img src="/assets/img/CV1/2Dlines_CV1.png" class="img-fluid rounded z-depth-1" width="100%" height="auto" loading="lazy" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"> </picture> </figure> </div> </div> <div class="caption"> Figure 2: 2D line equation where $\color{green}\hat{n}$ is the normal which is perpendicular to the line and $\color{green}d$ is the distance from the origin. <i>Image from book Computer Vision: Algorithms and Applications, 2nd ed. by Richard Szeliski<d-cite key="Szeliski:CV"></d-cite></i> </div> <p>Another important concept is the cross product. When using homogeneous coordinates, we can compute the intersection of two lines as \(\widetilde{\mathbf{x}} = \widetilde{\mathbf{l}}_1 \times \widetilde{\mathbf{l}}_2\) where the cross product is expressed as the product of a skew-symmetric matrix and a vector.<d-footnote>In this blog, we use squared brackets to distiguish matrices from vectors. </d-footnote></p> \[a \times b = [a]_\times b = \begin{bmatrix} 0 &amp; -a_3 &amp; a_2 \\ a_3 &amp; 0 &amp; -a_1 \\ -a_2 &amp; a_1 &amp; 0 \end{bmatrix} \begin{pmatrix} b_1 \\ b_2\\ b_3 \end{pmatrix} = \begin{pmatrix} a_2b_3 - a_3b_2 \\ a_3b1-a_1b_3 \\ a_1b_2-a_2b_1 \end{pmatrix}\] <p>Similarly, the line joining two points can be written as \(\widetilde{\mathbf{l}} = \bar{\mathbf{x}}_1 \times \bar{\mathbf{x}}_2\).</p> <blockquote> <p>How can we prove that indeed line joining two 2D points can be expressed as there cross products?</p> </blockquote> <details> <summary style="color:blue">Click to get the answer!</summary> <p style="color:blue"> Consider two lines in 2D homogeneous coordinates, $$\widetilde{\mathbf{l}}_1 = [a_1, b_1, c_1]^T$$ and $$\widetilde{\mathbf{l}}_2 = [a_2, b_2, c_2]^T$$ The lines can be represented as: $$\begin{align*} \widetilde{\mathbf{l}}_1 &amp;: a_1x + b_1y + c_1 = 0 \\ \widetilde{\mathbf{l}}_2 &amp;: a_2x + b_2y + c_2 = 0 \end{align*}$$ Now, consider a point $$\widetilde{x} = [x, y, 1]^T$$ that lies on both lines. This means: $$\begin{align*} \widetilde{\mathbf{l}}_1^T \widetilde{x} &amp;= 0 \\ \widetilde{\mathbf{l}}_2^T \widetilde{x} &amp;= 0 \end{align*}$$ This implies that $ \color{blue} \widetilde{\mathbf{x}}$ is orthogonal to both $\color{blue} \widetilde{\mathbf{l}}_1$ and $\color{blue} \widetilde{\mathbf{l}}_2$. The cross product of two vectors gives a vector which is orthogonal to both of the original vectors. Therefore, we can write: $$ [ \widetilde{x} = \widetilde{\mathbf{l}}_1 \times \widetilde{\mathbf{l}}_2 ] $$ This is the point of intersection of the two lines. Hence, the cross product provides a very convenient method for calculating the intersection point of two lines, which is why it's used in this context. It also generalizes easily to 3D, where the cross product of two planes gives their line of intersection. </p> </details> <div class="row mt-3"> <div class="col-sm mt-3 mt-md-0"> <figure> <picture> <img src="/assets/img/CV1/2Dlinearithmetic.png" class="img-fluid rounded z-depth-1" width="100%" height="auto" loading="lazy" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"> </picture> </figure> </div> </div> <div class="caption"> Figure 3: a. Skew symmetric matrix $\color{green}[\mathbf{x}]_\times$ (Right) b. Geometrical representation of the two lines $\color{green} y = 1$ and $\color{green} x = 2$ in both the Cartesian and homogeneous coordinates. c. Cross product of the two lines gives us the point of intersection $\color{green} (2,1)$ where $\color{green}\widetilde{\mathbf{l}}_1^\intercal$ is represented by the skew symmetric matrix. <i>Image from lecture slides of Computer Vision course taught by Prof. Dr. Andreas Geiger at University of Tuebingen.<d-cite key="Geiger:CV"></d-cite></i> </div> <div class="row mt-3"> <div class="col-sm mt-3 mt-md-0"> <figure> <picture> <img src="/assets/img/CV1/2Dlinearithmetic_2.png" class="img-fluid rounded z-depth-1" width="100%" height="auto" loading="lazy" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"> </picture> </figure> </div> </div> <div class="caption"> Figure 3: a. Skew symmetric matrix $\color{green}[\mathbb{x}]_\times$ (Right) b. Geometrical representation of the two lines $\color{green} x = 1$ and $\color{green} x = 2$ in both the Cartesian and homogeneous coordinates. c. Cross product of the two lines gives us (0,1,0) which indicates that the two lines are parallel and the intersection point is at infinity. <i>Image from lecture slides of Computer Vision course taught by Prof. Dr. Andreas Geiger at University of Tuebingen.<d-cite key="Geiger:CV"></d-cite></i> </div> <p>More complex algebraic objects can be represented using polynomial homogeneous equations. For example, a conic section can be represented as a homogeneous quadratic equation in 2D as:</p> \[\{\bar{\mathbf{x}}\vert\bar{\mathbf{x}}^\intercal \mathbb{Q} \bar{\mathbf{x}} = 0\}\] <p>where $\mathbb{Q}$ is a symmetric matrix. The conic section can be a circle, ellipse, parabola or hyperbola depending on the eigenvalues of $\mathbb{Q}$. This is useful for multi-view geometry and camera calibration. For more details see Hartley and Zisserman<d-cite key="Hartley:CV"></d-cite>.</p> <h3 id="3d-points">3D Points</h3> <p>3D points in inhomogeneous coordinates can be represented as</p> \[\mathbf{x} = \begin{pmatrix} x \\ y \\ z \end{pmatrix} \in \mathbb{R}^3\] <p>or in homogeneous coordinates as</p> \[\widetilde{\mathbf{x}} = \begin{pmatrix} \widetilde{x} \\ \widetilde{y} \\ \widetilde{z} \\ \widetilde{w} \end{pmatrix} \in \mathbb{P}^3\] <p>with projective space \(\mathbb{P}^3 = \mathbb{R}^4 \backslash \{(0,0,0,0)\}\)</p> <div class="row mt-3"> <div class="col-sm mt-3 mt-md-0"> <figure> <picture> <img src="/assets/img/CV1/3DPoints.png" class="img-fluid rounded z-depth-1" width="100%" height="auto" loading="lazy" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"> </picture> </figure> </div> </div> <div class="caption"> Figure 4: 3D line equation, r = (1 − λ)p + λq. The line is parameterized by λ ∈ R. The line passes through the points p and q. The line is infinite in both directions. <i>Image from book Computer Vision: Algorithms and Applications, 2nd ed. by Richard Szeliski<d-cite key="Szeliski:CV"></d-cite></i> </div> <h3 id="3d-planes">3D Planes</h3> <p>3D planes can also be represented in homogeneous coordinates as \(\widetilde{\mathbf{m}} = (a,b,c,d)^\intercal :\)</p> \[\{\mathbf{x}\hspace{0.2cm}\vert\hspace{0.2cm}\widetilde{\mathbf{m}}^\intercal\bar{\mathbf{x}}= 0\}\Leftrightarrow \{x,y,z\vert ax + by + cz + d = 0\}\] <p>Again we can normalize \(\widetilde{\mathbf{m}}\) so that \(\widetilde{\mathbf{m}} = (n_x,n_y,n_z,d)^\intercal = (\boldsymbol{n},d)^\intercal\) with \(\|\boldsymbol{n}\|_2 = 1\). In this case, <strong>n</strong> is the normal perpendicular to the plane and d is the distance of the plane from the origin.</p> <p>An exception is the plane at infinity, which is represented by \(\widetilde{\mathbf{m}} = (0,0,0,1)^\intercal\) which passes through all idead points for which \(\widetilde{w} = 0\).</p> <div class="row mt-3"> <div class="col-sm mt-3 mt-md-0"> <figure> <picture> <img src="/assets/img/CV1/3DPlanes.png" class="img-fluid rounded z-depth-1" width="100%" height="auto" loading="lazy" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"> </picture> </figure> </div> </div> <div class="caption"> Figure 5: 3D Plane. The plane is at a distance d from the origin in coordinate systems with the normal vector n. <i>Image from lecture slides of Computer Vision course taught by Prof. Dr. Andreas Geiger at University of Tuebingen.<d-cite key="Geiger:CV"></d-cite></i> </div> <h3 id="3d-lines">3D Lines</h3> <p>3D lines are less elegant than either 2D lines or 3D planes. One possible representation is to express points on a line as a linear combination of two points <strong>p</strong> and <strong>q</strong> on the line:</p> \[\{\mathbf{x}\vert\mathbf{x}=(1-\lambda)p + \lambda q \wedge \lambda \in \mathbb{R} \}\] <p>However, this representation uses 6 parameters for 4 degrees of freedom. <d-footnote>In the case of a 3D line, the line can be specified with four degrees of freedom: 1. Three degrees of freedom come from a point on the line, typically represented by a 3D coordinate (x, y, z). 2. The fourth degree of freedom comes from the direction of the line, which can be represented by the direction cosines of a unit vector along the line. </d-footnote></p> <p>A more compact representation is to use the <strong>two-plane parameterization</strong> or <strong>Plücker coordinates</strong>. More on this can be read in Hartley and Zisserman<d-cite key="Hartley:CV"></d-cite>.</p> <p>The 3D analog of 2D conics is a quadrix surface. They are useful in the study of multi-view geometry. They also serve as useful modeling primitives in terms of compact representations. E.g Superquadrics, in order to represent geometric objects in terms of simple primitives.</p> <h3 id="2d-transformations">2D Transformations</h3> <p>We will go through some common 2D transformations and their homogeneous representations.</p> <div class="row mt-3"> <div class="col-sm mt-3 mt-md-0"> <figure> <picture> <img src="/assets/img/CV1/2Dtransformations.png" class="img-fluid rounded z-depth-1" width="100%" height="auto" loading="lazy" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"> </picture> </figure> </div> </div> <div class="caption"> Figure 6: 2D Transformations. <i>Image from lecture slides of Computer Vision course taught by Prof. Dr. Andreas Geiger at University of Tuebingen.<d-cite key="Geiger:CV"></d-cite></i> </div> <h4 id="translation-2d-translation-2-degrees-of-freedom">Translation (2D Translation, 2 Degrees of Freedom)</h4> <p>Translation is a simple transformation that shifts the origin of the coordinate system by a fixed amount. In homogeneous coordinates, translation is represented by a matrix multiplication with a translation matrix:</p> \[x' = x + t \Leftrightarrow \bar{\mathbf{x}}' = \begin{bmatrix} \mathbf{I} &amp; t \\ 0^\intercal &amp; 1 \end{bmatrix} \bar{\mathbf{x}}\] <p>With homogeneous coordinates we can easily chain and invert transformations.</p> <h4 id="euclidean-transformation-2d-rotation--2d-translation-3-degrees-of-freedom">Euclidean Transformation (2D Rotation + 2D Translation, 3 Degrees of Freedom)</h4> <p>Euclidean transformations are rigid body transformations that preserve distances and angles. They are represented by a matrix multiplication with a Euclidean transformation matrix:</p> \[x' = \mathbf{R}x + t \Leftrightarrow \bar{\mathbf{x}}' = \begin{bmatrix} \mathbf{R} &amp; t \\ 0^\intercal &amp; 1 \end{bmatrix} \bar{\mathbf{x}}\] <p>where \(\mathbf{R}\) is a 2x2 rotation matrix and \(t\) is a 2D translation vector.</p> <p>\(\mathbf{R} \in SO(2)\) is an orthonormal rotation matrix with \(\mathbf{R}^\intercal\mathbf{R} = \mathbf{I}\) and \(\det(\mathbf{R}) = 1\). Euclidean transformations preserve Euclidean distances and angles.</p> <h4 id="similarity-transformation-2d-rotation--2d-translation--2d-scaling-4-degrees-of-freedom">Similarity Transformation (2D Rotation + 2D Translation + 2D Scaling, 4 Degrees of Freedom)</h4> <p>Similarity transformations are Euclidean transformations that also preserve scale. They are represented by a matrix multiplication with a similarity transformation matrix:</p> \[x' = s\mathbf{R}x + t \Leftrightarrow \bar{\mathbf{x}}' = \begin{bmatrix} s\mathbf{R} &amp; t \\ 0^\intercal &amp; 1 \end{bmatrix} \bar{\mathbf{x}}\] <p>where \(\mathbf{R}\) is a 2x2 rotation matrix, \(t\) is a 2D translation vector and \(s\) is a scaling factor. Even though they preserve angles, but now distances change as we have introduced a scaling factor. \(\mathbf{R} \in SO(0)\) is a rotation matrix and s is an arbitrary scaling factor.</p> <h4 id="affine-transformation-2d-rotation--2d-translation--2d-scaling--2d-shear-6-degrees-of-freedom">Affine Transformation (2D Rotation + 2D Translation + 2D Scaling + 2D Shear, 6 Degrees of Freedom)</h4> <p>Affine transformations are similarity transformations that also preserve parallel lines. They are represented by a matrix multiplication with an affine transformation matrix:</p> \[x' = s\mathbf{R}x + t \Leftrightarrow \bar{\mathbf{x}}' = \begin{bmatrix} \mathbf{A} &amp; t \\ 0^\intercal &amp; 1 \end{bmatrix} \bar{\mathbf{x}}\] <p>where \(\mathbf{A}\) is a 2x2 matrix and \(t\) is a 2D translation vector. Affine transformations preserve parallel lines, but not angles or distances.</p> <h4 id="projective-transformation-homography2d-rotation--2d-translation--2d-scaling--2d-shear--2d-perspective-8-degrees-of-freedom">Projective Transformation (Homography,2D Rotation + 2D Translation + 2D Scaling + 2D Shear + 2D Perspective, 8 Degrees of Freedom)</h4> \[\widetilde{\mathbf{x}}' = \mathbf{H}\widetilde{\mathbf{x}} (\bar{\mathbf{x}} = \frac{1}{\widetilde{w}}\widetilde{\mathbf{x}})\] <p>where \(\mathbf{H} \in \mathbb{R}^{3\times3}\) is an arbitrary homogeneous 3 × 3 matrix. Projective transformations preserve straight lines.</p> <h3 id="2d-transformations-on-co-vectors">2D Transformations on Co-Vectors</h3> <p>Considering any perspective 2D transformation:</p> \[\widetilde{\mathbf{x}}' = \mathbf{H}\widetilde{\mathbf{x}}\] <p>where \(\mathbf{H} \in \mathbb{R}^{3\times3}\) is an arbitrary homogeneous 3 × 3 matrix.</p> <p>The transformed 2D line equation is given by:</p> \[\widetilde{\mathbf{l}}'^\intercal \mathbf{x}'= \widetilde{\mathbf{l}}'^\intercal \widetilde{\mathbf{H}}\widetilde{\mathbf{x}} = (\widetilde{\mathbf{H}}^\intercal\widetilde{\mathbf{l}}')^\intercal = \widetilde{\mathbf{l}}^\intercal \widetilde{\mathbf{x}}= 0\] <p>Therefore we have:</p> \[\widetilde{\mathbf{l}}' = \widetilde{\mathbf{H}}^{-\intercal} \widetilde{\mathbf{l}}\] <p>Thus the action of a projective transformation on a co-vector such as a 2D line or 3D normal can be represented by the transposed inverse of the matrix.</p> <h3 id="overview-of-2d-transformations">Overview of 2D Transformations</h3> <div class="row mt-3"> <div class="col-sm mt-3 mt-md-0"> <figure> <picture> <img src="/assets/img/CV1/ov2Dtrans.png" class="img-fluid rounded z-depth-1" width="100%" height="auto" loading="lazy" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"> </picture> </figure> </div> </div> <div class="caption"> Figure 7: Overview of 2D Transformations. <i>Image from lecture slides of Computer Vision course taught by Prof. Dr. Andreas Geiger at University of Tuebingen.<d-cite key="Geiger:CV"></d-cite></i> </div> <p>These 2D transformations form nested set of groups as shown in the figure above. The group of Euclidean transformations is a subgroup of the group of similarity transformations, which is a subgroup of the group of affine transformations, which is a subgroup of the group of projective transformations. And the transformations preserve the properties below them. For example, Euclidean transformations preserve Euclidean distances and angles, while similarity transformations preserve angles but not distances.</p> <p>And as we go up from projective to translation transformation, more restrictions are imposed on the transformation.</p> <h3 id="overview-of-3d-transformations">Overview of 3D Transformations</h3> <div class="row mt-3"> <div class="col-sm mt-3 mt-md-0"> <figure> <picture> <img src="/assets/img/CV1/ov3Dtrans.png" class="img-fluid rounded z-depth-1" width="100%" height="auto" loading="lazy" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"> </picture> </figure> </div> </div> <div class="caption"> Figure 8: Overview of 3D Transformations. <i>Image from lecture slides of Computer Vision course taught by Prof. Dr. Andreas Geiger at University of Tuebingen.<d-cite key="Geiger:CV"></d-cite></i> </div> <p>3D transformations are defined analogously to 2D transformations. 3 x 4 matrices are extended with a fourth \([0^\intercal 1]\) row for homogeneous transforms. Also the transformations preserve the properties below them. For example, Euclidean transformations preserve Euclidean distances and angles, while similarity transformations preserve angles but not distances.</p> <h3 id="direct-linear-transform-for-homography-estimation">Direct Linear Transform for Homography Estimation</h3> <p>How can we estimate a homography from a set of point 2D correspondences?</p> <p>Let \(\mathbb{\chi} = \{\widetilde{\mathbf{x}}_i, \widetilde{\mathbf{x}}_i'\}_{i=1}^{N}\) denote a set of \(N\) point correspondences between two images, where \(\widetilde{\mathbf{x}}_i\) and \(\widetilde{\mathbf{x}}_i'\) are the homogeneous coordinates of the \(i\)-th point in the first and second image, respectively related by \(\widetilde{\mathbf{x}}' = \widetilde{H}\widetilde{\mathbf{x}}_i\).</p> <p>As the correspondence vectors are homogeneous, they have the same direction but differ in magnitude. Thus, the equation above can be expressed as \(\widetilde{\mathbf{x}}'_i \times \widetilde{H}\widetilde{\mathbf{x}}_i = 0.\)</p> <p>Using \(\widetilde{h}^\intercal_k\) to denote the k-th row of \(\widetilde{H}\), we can write linear equation in \(\widetilde{h}:\)</p> \[\underbrace{\left[\begin{array}{ccc} \mathbf{0}^{\top} &amp; -\tilde{w}_i^{\prime} \tilde{\mathbf{x}}_i^{\top} &amp; \tilde{y}_i^{\prime} \tilde{\mathbf{x}}_i^{\top} \\ \tilde{w}_i^{\prime} \tilde{\mathbf{x}}_i^{\top} &amp; \mathbf{0}^{\top} &amp; -\tilde{x}_i^{\prime} \tilde{\mathbf{x}}_i^{\top} \\ -\tilde{y}_i^{\prime} \tilde{\mathbf{x}}_i^{\top} &amp; \tilde{x}_i^{\prime} \tilde{\mathbf{x}}_i^{\top} &amp; \mathbf{0}^{\top} \end{array}\right]}_{\mathbf{A}_i} \underbrace{\left[\begin{array}{c} \tilde{\mathbf{h}}_1 \\ \tilde{\mathbf{h}}_2 \\ \tilde{\mathbf{h}}_3 \end{array}\right]}_{\tilde{\mathbf{h}}}=\mathbf{0}\] <p>Each point correspondence yields two equations. Stacking all the equations into a 2N x 9 dimensional matrix A leads to the following constrained least squares problem:</p> <p>\(\widetilde{h}^{*} = \underset{\widetilde{\mathbf{h}}}\arg \min \hspace{0.1cm}\|\mathbf{A}\widetilde{\mathbf{h}}\|_2^2 + \lambda(\|\widetilde{\mathbf{h}}\|_2^2 - 1)\) \(\widetilde{h}^{*} = \underset{\widetilde{\mathbf{h}}}\arg \min\hspace{0.1cm} \widetilde{\mathbf{h}}^\intercal\mathbf{A}^\intercal\mathbf{A}\widetilde{\mathbf{h}} + \lambda(\widetilde{\mathbf{h}}^\intercal \widetilde{\mathbf{h}} - 1)\)</p> <p>Here we have fixed \(\|\widetilde{\mathbf{h}}\|_2^2 = 1\) as \(\widetilde{\mathbf{H}}\) i.e defined only up to scale. And the trivial soltuion to the above equation is \(\widetilde{\mathbf{h}} = \mathbf{0}\), which is not useful. Thus, we need to add a constraint to the problem to make it solvable. The solution to the above optimization problem is the singular vector corresponding to the smallest singular value of \(\mathbf{A}\). The resulting algorithm is called the <strong>Direct Linear Transformation (DLT) algorithm</strong>.</p> <h3 id="panorama-stitching">Panorama Stitching</h3> <div class="row mt-3"> <div class="col-sm mt-3 mt-md-0"> <figure> <picture> <img src="/assets/img/CV1/principle-panoramic-photo-stitching.jpg" class="img-fluid rounded z-depth-1" width="100%" height="auto" loading="lazy" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"> </picture> </figure> </div> </div> <div class="caption"> Figure 9: Panorama Stitching. <i>Image from https://panoramic-photo-guide.com/best-photo-stitching-software-to-beginners.html</i> </div> </d-article> <d-appendix> <d-footnote-list></d-footnote-list> <d-citation-list></d-citation-list> </d-appendix> <d-bibliography src="/assets/bibliography/2023-05-25-CV.bib"></d-bibliography> </div> <footer class="fixed-bottom" role="contentinfo"> <div class="container mt-0"> © Copyright 2024 Suraj Bhor. Powered by <a href="https://jekyllrb.com/" target="_blank" rel="external nofollow noopener">Jekyll</a> with <a href="https://github.com/alshedivat/al-folio" rel="external nofollow noopener" target="_blank">al-folio</a> theme. Hosted by <a href="https://pages.github.com/" target="_blank" rel="external nofollow noopener">GitHub Pages</a>. Photos from <a href="https://unsplash.com" target="_blank" rel="external nofollow noopener">Unsplash</a>. </div> </footer> <script src="/assets/js/bootstrap.bundle.min.js"></script> <script src="https://cdn.jsdelivr.net/npm/mdbootstrap@4.20.0/js/mdb.min.js" integrity="sha256-NdbiivsvWt7VYCt6hYNT3h/th9vSTL4EDWeGs5SN3DA=" crossorigin="anonymous"></script> <script type="text/javascript">function progressBarSetup(){"max"in document.createElement("progress")?(initializeProgressElement(),$(document).on("scroll",function(){progressBar.attr({value:getCurrentScrollPosition()})}),$(window).on("resize",initializeProgressElement)):(resizeProgressBar(),$(document).on("scroll",resizeProgressBar),$(window).on("resize",resizeProgressBar))}function getCurrentScrollPosition(){return $(window).scrollTop()}function initializeProgressElement(){let e=$("#navbar").outerHeight(!0);$("body").css({"padding-top":e}),$("progress-container").css({"padding-top":e}),progressBar.css({top:e}),progressBar.attr({max:getDistanceToScroll(),value:getCurrentScrollPosition()})}function getDistanceToScroll(){return $(document).height()-$(window).height()}function resizeProgressBar(){progressBar.css({width:getWidthPercentage()+"%"})}function getWidthPercentage(){return getCurrentScrollPosition()/getDistanceToScroll()*100}const progressBar=$("#progress");window.onload=function(){setTimeout(progressBarSetup,50)};</script> </body> </html>